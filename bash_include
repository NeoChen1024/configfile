colorprompting='\[\e[1;31m\]\!\[\e[m\] [\[\e[1;33m\]\u\[\e[m\]@\[\e[1;32m\]\h\[\e[m\] \[\e[1;36m\]\w\[\e[m\]]\$ '
nocolorprompting='\! [\u@\h \w]\$ '

bgrunfiledir="$HOME/tmp/bgrun"

HISTSIZE=100000
HISTFILESIZE=100000

alias startcolor='PS1=$colorprompting'
alias stopcolor='PS1=$nocolorprompting'

alias ll='ls -l'
alias rm='rm -i'
alias cp='cp -pi'
alias mv='mv -i'
alias jobs='jobs -l'
alias less='less -RS'

alias cccc='LANG=C;LC_ALL=C'
alias enus='LANG=en_US.UTF-8;LC_ALL=en_US.UTF-8'
alias big5='LANG=zh_TW.Big5;LC_ALL=zh_TW.Big5'
alias zhtw='LANG=zh_TW.UTF-8;LC_ALL=zh_TW.UTF-8'
alias utf8='LANG=zh_TW.UTF-8;LC_ALL=zh_TW.UTF-8'

default_tty_setting=`stty -g`
alias savetty='default_tty_setting=`stty -g`'
alias resetty='stty $default_tty_setting'

alias sg='sudo -g'

# Function

function compile_all ()
{
	noask=0
	[ "$1" = '' ] && echo "Which file(s) do you want to compile? " && return 1
	[ "$1" = "-n" ] && noask=1
	if [ "$noask" = "0" ]; then
		read -p "CFLAGS [$CFLAGS] ? " NEWCFLAGS
		read -p "LDFLAGS [$LDFLAGS] ? " NEWLDFLAGS
		[ "$NEWCFLAGS" '!=' '' ] && CFLAGS=$NEWCFLAGS
		[ "$NEWLDFLAGS" '!=' '' ] && LDFLAGS=$NEWLDFLAGS
	else
		shift
	fi
	while [ "$1" '!=' '' ]
	do
		TARGETFILE="`echo "$1" | cut -d . -f 1`"
		SUFFIX="`echo "$1" | cut -d . -f 2`"
		if [ -f "$1" ]; then
			true
		else
		   	printf\
	   		'\e[1;33mWarning\e[0m: Non-existent file or not a regular file\n'
			shift ; continue
		fi
		[ "$TARGETFILE" = "$1" ] && shift && continue
		if [ "$SUFFIX" = "c" ]; then
			echo "[CC] $1 -> $TARGETFILE"
			gcc $CFLAGS "$1" $LDFLAGS -o "$TARGETFILE"
		elif [ "$SUFFIX" = "cpp" ]; then
			echo "[CXX] $1 -> $TARGETFILE"
			g++ $CFLAGS "$1" $LDFLAGS -o "$TARGETFILE"
		else
			printf 'Unknown suffix (\e[1;33mskipped\e[0m)\n'
		fi
		[ "$?" '!=' "0" ] && printf\
	   		'\e[1;31mError\e[0m while compiling file\n'
		shift
	done
	return 0
}


function convert_to_html ()
{
	while [ "$1" '!=' '' ]
	do
		for i in "$1"
		do 
			vim $i -c 'set background=dark' \
				-c 'highlight PreProc ctermfg=darkcyan' \
				-c "$BEFORE_CONVERT_TO_HTML" \
				-c TOhtml \
				-c :w \
				-c :qa 
		done
		shift
	done
}

function mkscreenacl ()
{
	PERMIT_COMMAND="select windowlist other meta detach reset hardcopy info redisplay lastmsg next prev xon xoff windows suspend help colon copy paste writebuf readbuf displays stuff attach"
	while [ "$1" '!=' '' ]
	do
		for i in $PERMIT_COMMAND
		do
			echo "aclchg $1 +x $i"
		done
		echo "aclchg $1 -rw \"#?\""	
		shift
	done
}

function bgrun ()
{
	[ "$#" = "0" ] && return 1
	[ '!' -d "$bgrunfiledir" ] && mkdir -p "$bgrunfiledir"
	current_time=`date "+%Y%m%d-%H%M%S"`
	filename="$bgrunfiledir/$1-$current_time"
	echo "Writing to $filename"
	"$@" &> "$filename" &
}

function bgview ()
{
	if [ "$1" = "" ]
	then
		yourchoice=1
	fi
	rootfilename=`find "$bgrunfiledir" -maxdepth 1 -mindepth 1 | cut -d - -f 2,3 | sort -r | sed -n ${yourchoice}p`
	realfilename=`find "$bgrunfiledir" -maxdepth 1 -mindepth 1 | grep "$rootfilename"`
	if [ "$PAGER" = "" ]
	then
		PAGER=less
	fi
	read -p "View '$realfilename' ? " confirm
	if [ "$confirm" = "n" ] || [ "$confirm" = "N" ]
	then
		return 1
	fi
	"$PAGER" "$realfilename"
}

function bgcount ()
{
	find "$bgrunfiledir" -maxdepth 1 -mindepth 1 | cut -d - -f 2,3 | wc | awk '{print $2}'
}

function check_dmesg ()
{
	[ "$#" = "0" ] && return 1

	while true
	do
		PREVIOS_DMESG_BUF="$DMESG_BUF"
		DMESG_BUF="`dmesg`"
		[ "$PREVIOS_DMESG_BUF" '!=' "$DMESG_BUF" ] && [ "$FIRST_RUN" = "0" ] && echo '===> system message buffer was modified <==='
		sleep $1
		[ "$?" '!=' "0" ] && return 1
		FIRST_RUN=0
	done 
}

# Starting doing something

startcolor

umask 0022

tty -s
if [ "$?" = "0" ]
then
    bind '"\e[A":history-search-backward'
	bind '"\e[B":history-search-forward'
fi

shopt -s histappend

# ~/check_dmesg.sh 5 &
